(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[3],{"/fXZ":function(n,e,t){n.exports=t.p+"static/noise.7c756fce.png"},"6loP":function(n,e,t){"use strict";t.r(e),t.d(e,"default",function(){return c});var o=t("q1tI"),i=t.n(o),a=t("Womt"),r=t("/fXZ"),u=t.n(r);class c extends i.a.Component{constructor(){super(...arguments),this.init=(()=>{var n,e,t,o,i,r,c=new a["h"];function l(){n=document.getElementById("container"),e=new a["a"],e.position.z=1,t=new a["f"];var u=new a["d"](2,2);i={u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new a["i"]},u_noise:{type:"t",value:r},u_mouse:{type:"v2",value:new a["i"]}};var c=new a["g"]({vertexShader:"   void main() {\n          gl_Position = vec4( position, 1.0 );\n      }",fragmentShader:' uniform vec2 u_resolution;\n      uniform vec2 u_mouse;\n      uniform float u_time;\n      uniform sampler2D u_noise;\n\n      #define PI 3.141592653589793\n      #define TAU 6.\n\n      const float multiplier = 25.5;\n\n      const float zoomSpeed = 10.;\n      const int layers = 10;\n\n      const int octaves = 5;\n\n      vec2 hash2(vec2 p)\n      {\n        vec2 o = texture2D( u_noise, (p+0.5)/256.0, -100.0 ).xy;\n        return o;\n      }\n\n      mat2 rotate2d(float _angle){\n          return mat2(cos(_angle),sin(_angle),\n                      -sin(_angle),cos(_angle));\n      }\n\n      vec3 hsb2rgb( in vec3 c ){\n        vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                                 6.0)-3.0)-1.0,\n                         0.0,\n                         1.0 );\n        rgb = rgb*rgb*(3.0-2.0*rgb);\n        return c.z * mix( vec3(1.0), rgb, c.y);\n      }\n\n      float hash(vec2 p)\n      {\n        float o = texture2D( u_noise, (p+0.5)/256.0, -100.0 ).x;\n        return o;\n      }\n      float noise(vec2 uv) {\n        vec2 id = floor(uv);\n        vec2 subuv = fract(uv);\n        vec2 u = subuv * subuv * (3. - 2. * subuv);\n        float a = hash(id);\n        float b = hash(id + vec2(1., 0.));\n        float c = hash(id + vec2(0., 1.));\n        float d = hash(id + vec2(1., 1.));\n        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n      }\n      float fbm(in vec2 uv) {\n        float s = .0;\n        float m = .0;\n        float a = .5;\n        for(int i = 0; i < octaves; i++) {\n          s += a * noise(uv);\n          m += a;\n          a *= .5;\n          uv *= 2.;\n        }\n        return s / m;\n      }\n\n      vec3 domain(vec2 z){\n        return vec3(hsb2rgb(vec3(atan(z.y,z.x)/TAU,1.,1.)));\n      }\n      vec3 colour(vec2 z) {\n          return domain(z);\n      }\n\n      // The render function is where we render the pattern to be added to the layer\n      vec3 render(vec2 uv, float scale, vec3 colour) {\n        vec2 id = floor(uv);\n        vec2 subuv = fract(uv);\n        vec2 rand = hash2(id);\n        float bokeh = abs(scale) * 1.;\n\n        float particle = 0.;\n\n        if(length(rand) > 1.3) {\n          vec2 pos = subuv-.5;\n          float field = length(pos);\n          particle = smoothstep(.3, 0., field);\n          particle += smoothstep(.4, 0.34 * bokeh, field);\n        }\n        return vec3(particle*2.);\n      }\n\n      vec3 renderLayer(int layer, int layers, vec2 uv, inout float opacity, vec3 colour, float n) {\n        vec2 _uv = uv;\n        // Scale\n        // Generating a scale value between zero and 1 based on a mod of u_time\n        // A frequency of 10 dixided by the layer index (10 / layers * layer)\n        float scale = mod((u_time + zoomSpeed / float(layers) * float(layer)) / zoomSpeed, -1.);\n        uv *= 20.; // The initial scale. Increasing this makes the cells smaller and the "speed" apepar faster\n        uv *= scale*scale; // then modifying the overall scale by the generated amount\n        // uv *= 1. + ( ( n*.5 ) * ( length(_uv) ) );\n        // uv += .5*float(layer);\n        uv = rotate2d(u_time / 10.) * uv; // rotarting\n        uv += vec2(25. + sin(u_time*.1)) * float(layer); // ofsetting the UV by an arbitrary amount to make the layer appear different\n\n        // render\n        vec3 pass = render(uv * multiplier, scale, colour) * .2; // render the pass\n\n         // this is the opacity of the layer fading in from the "bottom"\n        opacity = 1. + scale;\n        float _opacity = opacity;\n\n        // pass += n * .5 * mix(vec3(0., .5, 1.5), vec3(1., .5, 0.), opacity);\n\n        // This is the opacity of the layer fading out at the top (we want this minimal, hence the smoothstep)\n        float endOpacity = smoothstep(0., 0.4, scale * -1.);\n        opacity += endOpacity;\n\n        return pass * _opacity * endOpacity;\n      }\n\n      void main() {\n          vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy);\n\n          if(u_resolution.y < u_resolution.x) {\n            uv /= u_resolution.y;\n          } else {\n            uv /= u_resolution.x;\n          }\n\n          // uv.y += cos(u_time * .1) * .5;\n          // uv.x += sin(u_time * .1) * .5;\n\n          // float n = fbm(uv * 3. - 2.);\n          float n = fbm((uv + vec2(sin(u_time*.1), u_time*.1)) * 2. - 2.);\n\n          vec3 colour = vec3(0.);\n          // colour = n * mix(vec3(0., .5, 1.5), vec3(1., .5, -.1), n);\n          colour = n * mix(vec3(0., .5, 1.5), clamp(vec3(1., .5, .25)*2., 0., 1.), n);\n          // colour -= n*n*n*n*.4;\n          // colour += smoothstep(.8, 2.5, sin(n*n*n*8.))*.4;\n\n          float opacity = 1.;\n          float opacity_sum = 1.;\n\n          for(int i = 1; i <= layers; i++) {\n            colour += renderLayer(i, layers, uv, opacity, colour, n);\n            opacity_sum += opacity;\n          }\n\n          colour /= opacity_sum;\n\n          gl_FragColor = vec4(clamp(colour * 20., 0., 1.),1.0);\n      }',uniforms:i});c.extensions.derivatives=!0;var l=new a["c"](u,c);t.add(l),o=new a["j"],o.setPixelRatio(window.devicePixelRatio),n.appendChild(o.domElement),s(),window.addEventListener("resize",s,!1),document.addEventListener("pointermove",n=>{var e=window.innerHeight/window.innerWidth;i.u_mouse.value.x=(n.pageX-window.innerWidth/2)/window.innerWidth/e,i.u_mouse.value.y=(n.pageY-window.innerHeight/2)/window.innerHeight*-1,n.preventDefault()})}function s(){o.setSize(window.innerWidth,window.innerHeight),i.u_resolution.value.x=o.domElement.width,i.u_resolution.value.y=o.domElement.height}function v(n){requestAnimationFrame(v),d(n)}function d(n){i.u_time.value=5e-4*n-1e4,o.render(t,e)}c.setCrossOrigin("anonymous"),c.load(u.a,function(n){r=n,r.wrapS=a["e"],r.wrapT=a["e"],r.minFilter=a["b"],l(),v()})})}componentDidMount(){this.init()}render(){return i.a.createElement("div",{id:"container",style:{height:"100vh"}})}}}}]);